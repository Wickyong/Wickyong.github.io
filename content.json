{"meta":{"title":"Wickyong的博客","subtitle":"iOS是起点,不是终点","description":"一名iOS开发爱好者","author":"Wickyong","url":"https://Wickyong.github.io"},"pages":[{"title":"about","date":"2020-02-15T12:42:49.000Z","updated":"2020-02-15T12:42:49.799Z","comments":true,"path":"about/index.html","permalink":"https://wickyong.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS底层探秘之isa","slug":"2020-9-10","date":"2020-09-10T08:00:51.000Z","updated":"2020-09-10T09:22:51.333Z","comments":true,"path":"2020/09/10/2020-9-10/","link":"","permalink":"https://wickyong.github.io/2020/09/10/2020-9-10/","excerpt":"","text":"1[TOC] 一. iSA是什么?从源码可知: 结论: isa是对象alloc的时候，伴随初始化的一个属性,isa底层是一个isa_t结构的联合体. (什么是联合体?) 二. iSA的结构isa_t中包含cls类的指针,以及 ISA_BITFIELD 位域. 什么是位域? 位域指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 其中ISA_BITFIELD在不同环境下有不同定义: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869\\# if __arm64__\\# define ISA_MASK 0x0000000ffffffff8ULL\\# define ISA_MAGIC_MASK 0x000003f000000001ULL\\# define ISA_MAGIC_VALUE 0x000001a000000001ULL\\# define ISA_BITFIELD \\uintptr_t nonpointer : 1; \\uintptr_t has_assoc : 1; \\uintptr_t has_cxx_dtor : 1; \\uintptr_t shiftcls : 33; &#x2F;*MACH_VM_MAX_ADDRESS 0x1000000000*&#x2F; \\uintptr_t magic : 6; \\uintptr_t weakly_referenced : 1; \\uintptr_t deallocating : 1; \\uintptr_t has_sidetable_rc : 1; \\uintptr_t extra_rc : 19\\# define RC_ONE (1ULL&lt;&lt;45)\\# define RC_HALF (1ULL&lt;&lt;18)\\# elif __x86_64__\\# define ISA_MASK 0x00007ffffffffff8ULL\\# define ISA_MAGIC_MASK 0x001f800000000001ULL\\# define ISA_MAGIC_VALUE 0x001d800000000001ULL\\# define ISA_BITFIELD \\uintptr_t nonpointer : 1; \\uintptr_t has_assoc : 1; \\uintptr_t has_cxx_dtor : 1; \\uintptr_t shiftcls : 44; &#x2F;*MACH_VM_MAX_ADDRESS 0x7fffffe00000*&#x2F; \\uintptr_t magic : 6; \\uintptr_t weakly_referenced : 1; \\uintptr_t deallocating : 1; \\uintptr_t has_sidetable_rc : 1; \\uintptr_t extra_rc : 8\\# define RC_ONE (1ULL&lt;&lt;56)\\# define RC_HALF (1ULL&lt;&lt;7)\\# else\\# error unknown architecture for packed isa\\# endif 三. ISA_BITFIELD参数分析 (上图对应 arm64 架构) nonpointer：表示是否对 isa 指针开启指针优化. 0：纯isa指针，1：不⽌是类对象地址,isa 中包含了类信息、对象的引⽤计数等 has_assoc：关联对象标志位，0没有，1存在 has_cxx_dtor：该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象 shiftcls: 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位⽤来存储类指针。 magic：⽤于调试器判断当前对象是真的对象还是没有初始化的空间 weakly_referenced：标志对象是否被指向或者曾经指向⼀个 ARC 的弱变量，没有弱引⽤的对象可以更快释放。 deallocating：标志对象是否正在释放内存 has_sidetable_rc：当对象引⽤计数值⼤于 10 时，则需要借⽤该变量存储进位 extra_rc：当表示该对象的引⽤计数值，实际上是引⽤计数值减 1，例如，如果对象的引⽤计数为 10，那么 extra_rc 为 9。如果引⽤计数⼤于 10，则需要使⽤到下⾯的 has_sidetable_rc。 那么isa具体是怎么运行的呢? 未完待续…","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"底层原理","slug":"底层原理","permalink":"https://wickyong.github.io/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"Lottie动画框架的简单使用","slug":"2020-4-11","date":"2020-04-11T05:38:51.000Z","updated":"2020-04-17T07:33:32.194Z","comments":true,"path":"2020/04/11/2020-4-11/","link":"","permalink":"https://wickyong.github.io/2020/04/11/2020-4-11/","excerpt":"","text":"Lottie 是 Airbnb 开源的一个动画框架, 可以支持多平台,如iOS,Android,RN,Flutter等. 和平时iOS开发中用一行行代码编写的动画不同, lottie动画框架是由专业的动画设计师设计的. 然后通过Bodymovin插件进行导出,导出的文件为json文件. Lottie官方平台网站: https://lottiefiles.com 其原理是将通过由After Effects设计编辑的动画效果,通过json,来映射到iOS相应的动画变换类的属性中,通过CoreAnimation进行动画渲染. 相比手动写动画代码,直接导入json文件着实方便不少. 使用步骤如下: 通过CocoaPods集成Lottie框架 12#pod &#39;lottie-ios&#39;, &#39;~&gt; 3.1.6&#39;#For Swiftpod &#39;lottie-ios&#39;, &#39;~&gt; 2.5.3&#39;#For OC 然后可以尝试在Lottie网站上下载一个json动画文件,拖入到工程中,再将json文件名写入代码中,示例如下: 12345678LOTAnimationView * animationView &#x3D; [LOTAnimationView animationNamed:@&quot;222-trail-loading&quot;];animationView.loopAnimation &#x3D; YES;animationView.frame &#x3D; self.view.bounds;[self.view addSubview:animationView];[animationView playWithCompletion:^(BOOL animationFinished) &#123; &#x2F;&#x2F;动画完成后执行 &#x2F;&#x2F;当loopAnimation &#x3D; YES时,循环播放的时候不执行&#125;]; Lottie还有一些其他的属性,如手势联动动画,配合LOTAnimationView 的 animationProgress 属性进行控制; 123456789@property (nonatomic, readonly) BOOL isAnimationPlaying;&#x2F;&#x2F;判断动画是否在播放@property (nonatomic, assign) BOOL loopAnimation;&#x2F;&#x2F;是否要循环播放动画@property (nonatomic, assign) CGFloat animationProgress;&#x2F;&#x2F;自定义动画的播放进度@property (nonatomic, assign) CGFloat animationSpeed;&#x2F;&#x2F;自定义动画的播放速度@property (nonatomic, readonly) CGFloat animationDuration;&#x2F;&#x2F;自定义动画的播放时长 Lottie也支持自定义页面切换的过场动画,通过设置 present／dismiss controller 转场动画, 在需要转场效果的VC中实现UIViewControllerTransitioningDelegate代理中下面的两个方法: 12345678910111213141516#pragma mark -- 定制转场动画&#x2F;&#x2F; 代理返回推出控制器的动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名1&quot; fromLayerNamed:@&quot;来自哪个图层的图层名1&quot; toLayerNamed:@&quot;去到哪个图层的图层名1&quot; applyAnimationTransform:NO]; return animationController;&#125;&#x2F;&#x2F; 代理返回退出控制器的动画- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名2&quot; fromLayerNamed:@&quot;来自哪个图层的图层名2&quot; toLayerNamed:@&quot;去到哪个图层的图层名2&quot; applyAnimationTransform:NO]; return animationController;&#125;&#x2F;&#x2F;后两个属性fromLayerNamed,toLayerNamed 可不填 最后附上Lottie的iOS/Mac版官方教程地址: http://airbnb.io/lottie/#/ios","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"App耗电量检测","slug":"2020-4-5","date":"2020-04-05T11:08:53.000Z","updated":"2020-04-16T11:38:00.373Z","comments":true,"path":"2020/04/05/2020-4-5/","link":"","permalink":"https://wickyong.github.io/2020/04/05/2020-4-5/","excerpt":"","text":"虽说现在iOS手机的电池续航越来越持久了,实在不行还有充电宝,快充设备,耗电量似乎不是问题,对用户感知不明显,用户会觉得是手机整体耗电量大,或者机子老化… 作为iOS开发者,还是要对自己开发的App精益求精,所以耗电量问题实际上还是要研究一下的.查看耗电量问题,需要知道是代码哪个地方出现问题,或者说是哪个线程有问题. 1234thread_act_array_t threads;mach_msg_type_number_t threadsCount &#x3D; 0;const task_t thisTask &#x3D; mach_task_self();kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount); task_threads 是一个关于线程组的函数，通过这个函数可以获得所有的线程信息数组 threads，线程总数 threadsCount。threads 数组里的线程信息有个结构体 thread_basic_info,该结构体里有一个字段 cpu_usage, cpu_usage 记录了 CPU 使用百分比。 其中thread_basic_info 结构体: 12345678910struct thread_basic_info &#123; time_value_t user_time; &#x2F;* user 运行的时间 *&#x2F; time_value_t system_time; &#x2F;* system 运行的时间 *&#x2F; integer_t cpu_usage; &#x2F;* CPU 使用百分比 *&#x2F; policy_t policy; &#x2F;* 有效的计划策略 *&#x2F; integer_t run_state; &#x2F;* run state (see below) *&#x2F; integer_t flags; &#x2F;* various flags (see below) *&#x2F; integer_t suspend_count; &#x2F;* suspend count for thread *&#x2F; integer_t sleep_time; &#x2F;* 休眠时间 *&#x2F;&#125;; 通过 cpu_usage 字段，来遍历所有的线程，然后查看是哪个线程的 CPU 使用百分比过高了。 比如某个线程对应的CPU使用率值一直保持很高的数字,比如80%,那可以认为是该线程在耗电。 如果想具体到哪段代码引起了耗电问题, 那就记录该线程对应方法堆栈 ,并反向查找出是哪段代码的问题了。 通过以上步骤，可以快速定位到问题，有针对性地进行Code优化。 遍历检查多个线程信息里的CPU使用率的示例代码: 123456789101112131415161718192021222324+ (void)checkCPU_Usage &#123; thread_act_array_t threads; mach_msg_type_number_t threadsCount &#x3D; 0; const task_t thisTask &#x3D; mach_task_self(); kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount); if (kr !&#x3D; KERN_SUCCESS) &#123; return; &#125; for (int i &#x3D; 0; i &lt; threadCount; i++) &#123; thread_info_data_t threadInfo; thread_basic_info_t threadBaseInfo; mach_msg_type_number_t threadInfoCount &#x3D; THREAD_INFO_MAX; if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) &#x3D;&#x3D; KERN_SUCCESS) &#123; threadBaseInfo &#x3D; (thread_basic_info_t)threadInfo; if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123; integer_t cpuUsage &#x3D; threadBaseInfo-&gt;cpu_usage &#x2F; 10; if (cpuUsage &gt; 80) &#123; NSString *stackStr &#x3D; stackOfThread(threads[i]); NSLog(@&quot;CPU 使用对应线程堆栈：\\n%@&quot;,stackStr); &#125; &#125; &#125; &#125;&#125; (注:本文参考了戴铭的极客时间专栏)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"iOS中获取内存值的方法","slug":"2020-3-31","date":"2020-03-31T08:01:06.000Z","updated":"2020-04-16T11:38:19.265Z","comments":true,"path":"2020/03/31/2020-3-31/","link":"","permalink":"https://wickyong.github.io/2020/03/31/2020-3-31/","excerpt":"","text":"iOS 系统提供了一个函数 task_info， 可以获取到当前任务的信息。 调用该函数需要导入头文件: 12#import &lt;sys&#x2F;sysctl.h&gt;#import &lt;mach&#x2F;mach.h&gt; 代码如下： 12345struct mach_task_basic_info info;mach_msg_type_number_t size &#x3D; sizeof(info);kern_return_t kl &#x3D; task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size); 在这段代码中，名为 task_info_t 的结构里包含了一个 resident_size 字段，用于表示使用了多少内存。 当发现有App内存警告，可以借此获取当前 App 占用了多少内存。代码如下： 123float used_memory &#x3D; info.resident_size;NSLog(@&quot;App占用了 %f MB 的内存&quot;, used_memory &#x2F; 1024.0f &#x2F; 1024.0f); 另外 ,也可以获取当前设备可用的内存, 代码如下: 12345678vm_statistics_data_t vmStats;mach_msg_type_number_t infoCount &#x3D; HOST_VM_INFO_COUNT;kern_return_t kernReturn &#x3D; host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount);float free_memory &#x3D; vm_page_size *vmStats.free_count;NSLog(@&quot;App可用 %f MB 内存&quot;, free_memory &#x2F; 1024.0f &#x2F; 1024.0f);","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"利用RunLoop监控卡顿","slug":"2020-3-28","date":"2020-03-28T01:42:49.000Z","updated":"2020-04-16T08:00:37.263Z","comments":true,"path":"2020/03/28/2020-3-28/","link":"","permalink":"https://wickyong.github.io/2020/03/28/2020-3-28/","excerpt":"","text":"利用RunLoop监控卡顿 通过学习了戴铭大神的专栏, Get到了在App开发过程中可以利用Runloop来监控App在运行期间的卡顿,卡顿问题是老生常谈 ,并且很影响用户体验,这里截取部分关键步骤,作为自己的参考. RunLoop的6种状态 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry , &#x2F;&#x2F; 进入 loop kCFRunLoopBeforeTimers , &#x2F;&#x2F; 触发 Timer 回调 kCFRunLoopBeforeSources , &#x2F;&#x2F; 触发 Source0 回调 kCFRunLoopBeforeWaiting , &#x2F;&#x2F; 等待 mach_port 消息 kCFRunLoopAfterWaiting ), &#x2F;&#x2F; 接收 mach_port 消息 kCFRunLoopExit , &#x2F;&#x2F; 退出 loop kCFRunLoopAllActivities &#x2F;&#x2F; loop 所有状态改变&#125; 监听 RunLoop，首先需要创建一个 CFRunLoopObserverContext 观察者 12CFRunLoopObserverContext context &#x3D; &#123;0,(__bridge void*)self,NULL,NULL&#125;;runLoopObserver &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context); 将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长. 开启一个子线程监控的代码如下： 1234567891011121314151617181920&#x2F;&#x2F;创建子线程监控dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; &#x2F;&#x2F;子线程开启一个持续的 loop 用来进行监控 while (YES) &#123; long semaphoreWait &#x3D; dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC)); if (semaphoreWait !&#x3D; 0) &#123; if (!runLoopObserver) &#123; timeoutCount &#x3D; 0; dispatchSemaphore &#x3D; 0; runLoopActivity &#x3D; 0; return; &#125; &#x2F;&#x2F;BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿 if (runLoopActivity &#x3D;&#x3D; kCFRunLoopBeforeSources || runLoopActivity &#x3D;&#x3D; kCFRunLoopAfterWaiting) &#123; &#x2F;&#x2F;将堆栈信息上报服务器的代码放到这里 &#125; &#x2F;&#x2F;end activity &#125;&#x2F;&#x2F; end semaphore wait timeoutCount &#x3D; 0; &#125;&#x2F;&#x2F; end while&#125;); 获取卡顿的方法堆栈信息 获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下: 123456789101112131415161718192021222324252627282930313233343536373839static int s_fatal_signals[] &#x3D; &#123; SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP, SIGTERM, SIGKILL,&#125;;static int s_fatal_signal_num &#x3D; sizeof(s_fatal_signals) &#x2F; sizeof(s_fatal_signals[0]);void UncaughtExceptionHandler(NSException *exception) &#123; NSArray *exceptionArray &#x3D; [exception callStackSymbols]; &#x2F;&#x2F;得到当前调用栈信息 NSString *exceptionReason &#x3D; [exception reason]; &#x2F;&#x2F;非常重要，就是崩溃的原因 NSString *exceptionName &#x3D; [exception name]; &#x2F;&#x2F;异常类型&#125;void SignalHandler(int code)&#123; NSLog(@&quot;signal handler &#x3D; %d&quot;,code);&#125;void InitCrashReport()&#123; &#x2F;&#x2F;系统错误信号捕获 for (int i &#x3D; 0; i &lt; s_fatal_signal_num; ++i) &#123; signal(s_fatal_signals[i], SignalHandler); &#125; &#x2F;&#x2F;oc未捕获异常的捕获 NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; InitCrashReport(); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); 另一种方法是，直接用 PLCrashReporter这个开源的第三方库来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是戴铭大神推荐的获取堆栈信息的方法。具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示： 12345678&#x2F;&#x2F; 获取数据NSData *lagData &#x3D; [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];&#x2F;&#x2F; 转换成 PLCrashReport 对象PLCrashReport *lagReport &#x3D; [[PLCrashReport alloc] initWithData:lagData error:NULL];&#x2F;&#x2F; 进行字符串格式化处理NSString *lagReportString &#x3D; [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];&#x2F;&#x2F;将字符串上传服务器NSLog(@&quot;lag happen, detail below: \\n %@&quot;,lagReportString); 搜集到卡顿的方法堆栈信息以后，分析并解决卡顿问题。 (以上内容摘自戴铭的极客时间专栏)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"Git在终端中的一些常用命令","slug":"2020-3-26","date":"2020-03-26T11:09:42.000Z","updated":"2020-09-10T07:51:48.297Z","comments":true,"path":"2020/03/26/2020-3-26/","link":"","permalink":"https://wickyong.github.io/2020/03/26/2020-3-26/","excerpt":"","text":"Git在终端中的一些常用命令 公司以自有服务器搭建gitLab用于代码托管, 虽说有像source tree, Tower等非常好用的可视化git管理软件,但也有很多人热衷于在终端上使用git命令,有种返璞归真的意思,今天就自己简单回顾了一些常用的git命令, 毕竟好记性不如烂笔头. git mv xxx kkkk #简便修改git文件的文件名 然后直接commit 提交 git log —oneline #查看简便log历史 git log —all #查看所有log所有分支 git log —graph #查看可视化log历史 git log —n4 #查看所有log记录的前4条 (commit:保存的快照,tree:相当于文件夹 ,blob:相当于文件) git cat-file -p 1234567..(hash值) #通过hash值查看git文件 git cat-file -t 1234567..(hash值) #通过hash值查看git文件格式(commit/tree/blob) git diff 123456 7891011 #通过两个commit的hash值比较变更差异 git diff HEAD HEAD^1^1 (等同于git diff HEAD HEAD^^ 或git diff HEAD HEAD~2) #比较当前HEAD和父HEAD的父HEAD的变更差异 git branch -D 123456(分支名) #删除指定名字的分支 git commit -amend #对最近的一次commit的message做修改变更 git rebase -i 1234(需要修改的commit的父commit) #对历史任意一次commit做变更 git rebase -i #pick改为s 进行commit合并 git diff —cached #比较暂存区和HEAD所含文件的差异 git reset HEAD #让暂存区恢复成和HEAD的一样,命令后可跟具体 文件名,即可具体到指定文件 git checkout — 文件名 #让工作区的文件恢复为和暂存区一样 git reset —hard 123456(commit的hash值) #消除最近到指定某次commit的提交 git rm filename #删除指定文件并同步到暂存区 git stash #提交工作区文件到暂存区 git stash list #查看暂存区文件列表 git stash pop #将暂存区文件恢复到工作区,且暂存区内容清除 git stash apply ##将暂存区文件恢复到工作区,且暂存区内容保留 .gitignore 指定不需要git管理的文件 git clone #git仓库备份到本地 git push #本地提交到git仓库 git remote -v #查看本地和远程建立联系的列表 git merge #由git智能合并 git push -f #强制更新(不建议使用) ……暂时写这么多吧","categories":[{"name":"工具","slug":"工具","permalink":"https://wickyong.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://wickyong.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"关于静态分析工具 infer 的简单使用","slug":"2020-3-5","date":"2020-03-05T11:16:28.000Z","updated":"2020-03-05T13:59:18.823Z","comments":true,"path":"2020/03/05/2020-3-5/","link":"","permalink":"https://wickyong.github.io/2020/03/05/2020-3-5/","excerpt":"","text":"静态分析工具 infer 的简单使用 在iOS开发中或许会用到一款用于静态分析的工具 - infer, 对于这个工具的出处和原理,网上也有相关介绍. 这里,简单记录一下使用步骤: 1)安装: ​ 终端输入: ​ brew install infer ​ 涉及到软件更新,依赖库安装,安装时间可能较长,具体依网络状况而定. 2)使用: ​ 终端进入项目目录: ​ $ cd &lt;项目所在目录&gt; ​ 使用如下命令编译: ​ infer – xcodebuild -target 项目名 -configuration Debug -sdk iphonesimulator ​ 接下来终端中会出现日志信息打印. 3)结果 ​ 在项目所在目录出现 “build”及”infer-out”目录 ​ “infer-out”文件夹中有txt,json等相关文件,分析bugs.txt. 4)再次使用 ​ 由于infer有两种模式:增量与非增量模式 ​ a)增量模式:是在第一次运行 “2)中的编译命令” 后,产生了build和infer-out文件夹, ​ 再次执行该编译命令时,此时就是增量模式.当项目的代码没有改动时,则此时不会有编译结果, 如果项目代码有新的改动之处,此次编译就只产生新的编译结果. ​ b)非增量模式:当再次执行编译命令前,删除了build和infer-out两个文件夹的时候,执行命令,则会输出所有的编译信息,相当于首次编译的情形. ​ 所以手动使用非增量模式的方法: ​ 一: 执行编译命令前,先删除build和infer-out文件夹(如果有的话) ​ 二: 在编译命令的最后追加”clean”, 即: ​ xcodebuild -target 项目名称 -configuration Debug -sdk iphonesimulator clean ​ 对于infer静态分析的原理,感兴趣可以google一下.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://wickyong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://wickyong.github.io/categories/iOS/"}]},{"title":"随笔一则","slug":"2020-2-16","date":"2020-02-16T05:31:31.000Z","updated":"2020-03-05T13:54:32.586Z","comments":false,"path":"2020/02/16/2020-2-16/","link":"","permalink":"https://wickyong.github.io/2020/02/16/2020-2-16/","excerpt":"","text":"​ 昨晚外面还在风雨交加,今天就是个大太阳,就是温度有点低. ​ 看今天的网络,仿佛一场自发的摄影大赛,各种抓拍的雪景,虽说疫情当前,但这场短暂的春雪还是给广大网友们带来了一丝快乐,毕竟大家都在家憋坏了…… ​ 昨晚还看到东南亚一些国家发出了”放弃疫情防治措施”的新闻,貌似那边就是百姓该吃吃该喝喝,社会正常运作的意思,想来疫情程度不同,号称新冠病杀伤力不如Sara,于是放弃抵抗?! ​ 昨晚西甲的一场比赛,赛前为”中国加油,武汉加油”的仪式还是挺暖心的…咱武汉同胞要加油! ​ ​","categories":[{"name":"生活","slug":"生活","permalink":"https://wickyong.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://wickyong.github.io/tags/%E6%97%A5%E5%B8%B8/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://wickyong.github.io/categories/%E7%94%9F%E6%B4%BB/"}]},{"title":"开篇","slug":"2020-2-15","date":"2020-02-15T13:22:06.000Z","updated":"2020-02-16T05:52:06.000Z","comments":true,"path":"2020/02/15/2020-2-15/","link":"","permalink":"https://wickyong.github.io/2020/02/15/2020-2-15/","excerpt":"","text":"2020年开年的事,大家都知道了,目前仍然在经历着… 由于各方面政策的原因,一直宅着,那就找点事情捣鼓捣鼓吧:买了云主机,开了VPN, 订了网上课程…其实我只是想搭个个人博客,那么,这就是 2020年 的第一篇博文吧.","categories":[{"name":"生活","slug":"生活","permalink":"https://wickyong.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://wickyong.github.io/tags/%E6%97%A5%E5%B8%B8/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://wickyong.github.io/categories/%E7%94%9F%E6%B4%BB/"}]}]}