<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>探索&quot;离屏渲染&quot;</title>
    <url>/2020/07/07/2020-7-7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Lottie动画框架的简单使用</title>
    <url>/2020/04/11/2020-4-11/</url>
    <content><![CDATA[<p>Lottie 是 Airbnb 开源的一个动画框架, 可以支持多平台,如iOS,Android,RN,Flutter等.</p>
<p>和平时iOS开发中用一行行代码编写的动画不同, lottie动画框架是由专业的动画设计师设计的.</p>
<p>然后通过Bodymovin插件进行导出,导出的文件为json文件.</p>
<p>Lottie官方平台网站:</p>
<p><a href="https://lottiefiles.com" target="_blank" rel="noopener">https://lottiefiles.com</a></p>
<p>其原理是将通过由After Effects设计编辑的动画效果,通过json,来映射到iOS相应的动画变换类的属性中,通过CoreAnimation进行动画渲染. 相比手动写动画代码,直接导入json文件着实方便不少.</p>
<p><img src="Loading.gif" alt=""></p>
<p>使用步骤如下:</p>
<p>通过CocoaPods集成Lottie框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pod &#39;lottie-ios&#39;, &#39;~&gt; 3.1.6&#39;#For Swift</span><br><span class="line">pod &#39;lottie-ios&#39;, &#39;~&gt; 2.5.3&#39;#For OC</span><br></pre></td></tr></table></figure>

<p>然后可以尝试在Lottie网站上下载一个json动画文件,拖入到工程中,再将json文件名写入代码中,示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOTAnimationView * animationView &#x3D; [LOTAnimationView animationNamed:@&quot;222-trail-loading&quot;];</span><br><span class="line">animationView.loopAnimation &#x3D; YES;</span><br><span class="line">animationView.frame &#x3D; self.view.bounds;</span><br><span class="line">[self.view addSubview:animationView];</span><br><span class="line">[animationView playWithCompletion:^(BOOL animationFinished) &#123;</span><br><span class="line">    &#x2F;&#x2F;动画完成后执行</span><br><span class="line">    &#x2F;&#x2F;当loopAnimation &#x3D; YES时,循环播放的时候不执行</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>Lottie还有一些其他的属性,如手势联动动画,配合LOTAnimationView 的 animationProgress 属性进行控制;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readonly) BOOL isAnimationPlaying;&#x2F;&#x2F;判断动画是否在播放</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL loopAnimation;&#x2F;&#x2F;是否要循环播放动画</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat animationProgress;&#x2F;&#x2F;自定义动画的播放进度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat animationSpeed;&#x2F;&#x2F;自定义动画的播放速度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) CGFloat animationDuration;&#x2F;&#x2F;自定义动画的播放时长</span><br></pre></td></tr></table></figure>

<p>Lottie也支持自定义页面切换的过场动画,通过设置 present／dismiss controller 转场动画, 在需要转场效果的VC中实现UIViewControllerTransitioningDelegate代理中下面的两个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark -- 定制转场动画</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理返回推出控制器的动画</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123;</span><br><span class="line">  LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名1&quot; fromLayerNamed:@&quot;来自哪个图层的图层名1&quot; toLayerNamed:@&quot;去到哪个图层的图层名1&quot; applyAnimationTransform:NO];</span><br><span class="line">  return animationController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理返回退出控制器的动画</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123;</span><br><span class="line">  LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名2&quot; fromLayerNamed:@&quot;来自哪个图层的图层名2&quot; toLayerNamed:@&quot;去到哪个图层的图层名2&quot; applyAnimationTransform:NO];</span><br><span class="line">  return animationController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后两个属性fromLayerNamed,toLayerNamed 可不填</span><br></pre></td></tr></table></figure>

<p>最后附上Lottie的iOS/Mac版官方教程地址:</p>
<p><a href="http://airbnb.io/lottie/#/ios" target="_blank" rel="noopener">http://airbnb.io/lottie/#/ios</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>App耗电量检测</title>
    <url>/2020/04/05/2020-4-5/</url>
    <content><![CDATA[<p>虽说现在iOS手机的电池续航越来越持久了,实在不行还有充电宝,快充设备,耗电量似乎不是问题,对用户感知不明显,用户会觉得是手机整体耗电量大,或者机子老化…</p>
<p>作为iOS开发者,还是要对自己开发的App精益求精,所以耗电量问题实际上还是要研究一下的.查看耗电量问题,需要知道是代码哪个地方出现问题,或者说是哪个线程有问题.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread_act_array_t threads;</span><br><span class="line">mach_msg_type_number_t threadsCount &#x3D; 0;</span><br><span class="line">const task_t thisTask &#x3D; mach_task_self();</span><br><span class="line">kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount);</span><br></pre></td></tr></table></figure>

<p>task_threads 是一个关于线程组的函数，通过这个函数可以获得所有的线程信息数组 threads，线程总数 threadsCount。threads 数组里的线程信息有个结构体 thread_basic_info,该结构体里有一个字段 cpu_usage, cpu_usage 记录了 CPU 使用百分比。</p>
<p>其中thread_basic_info 结构体:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">        time_value_t    user_time;      &#x2F;* user 运行的时间 *&#x2F;</span><br><span class="line">        time_value_t    system_time;    &#x2F;* system 运行的时间 *&#x2F;</span><br><span class="line">        integer_t       cpu_usage;      &#x2F;* CPU 使用百分比 *&#x2F;</span><br><span class="line">        policy_t        policy;         &#x2F;* 有效的计划策略 *&#x2F;</span><br><span class="line">        integer_t       run_state;      &#x2F;* run state (see below) *&#x2F;</span><br><span class="line">        integer_t       flags;          &#x2F;* various flags (see below) *&#x2F;</span><br><span class="line">        integer_t       suspend_count;  &#x2F;* suspend count for thread *&#x2F;</span><br><span class="line">        integer_t       sleep_time;     &#x2F;* 休眠时间 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 cpu_usage 字段，来遍历所有的线程，然后查看是哪个线程的 CPU 使用百分比过高了。</p>
<p>比如某个线程对应的CPU使用率值一直保持很高的数字,比如80%,那可以认为是该线程在耗电。</p>
<p>如果想具体到哪段代码引起了耗电问题, 那就记录该线程对应方法堆栈 ,并反向查找出是哪段代码的问题了。</p>
<p>通过以上步骤，可以快速定位到问题，有针对性地进行Code优化。</p>
<p>遍历检查多个线程信息里的CPU使用率的示例代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)checkCPU_Usage &#123;</span><br><span class="line">    thread_act_array_t threads;</span><br><span class="line">    mach_msg_type_number_t threadsCount &#x3D; 0;</span><br><span class="line">    const task_t thisTask &#x3D; mach_task_self();</span><br><span class="line">    kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount);</span><br><span class="line">    if (kr !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        thread_info_data_t threadInfo;</span><br><span class="line">        thread_basic_info_t threadBaseInfo;</span><br><span class="line">        mach_msg_type_number_t threadInfoCount &#x3D; THREAD_INFO_MAX;</span><br><span class="line">        if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) &#x3D;&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">            threadBaseInfo &#x3D; (thread_basic_info_t)threadInfo;</span><br><span class="line">            if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">                integer_t cpuUsage &#x3D; threadBaseInfo-&gt;cpu_usage &#x2F; 10;</span><br><span class="line">                if (cpuUsage &gt; 80) &#123;</span><br><span class="line">                    NSString *stackStr &#x3D; stackOfThread(threads[i]);</span><br><span class="line">                  	NSLog(@&quot;CPU 使用对应线程堆栈：\n%@&quot;,stackStr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(注:本文参考了戴铭的极客时间专栏)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中获取内存值的方法</title>
    <url>/2020/03/31/2020-3-31/</url>
    <content><![CDATA[<p>iOS 系统提供了一个函数 task_info， 可以获取到当前任务的信息。</p>
<p>调用该函数需要导入头文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;sys&#x2F;sysctl.h&gt;</span><br><span class="line">#import &lt;mach&#x2F;mach.h&gt;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct mach_task_basic_info info;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t size &#x3D; sizeof(info);</span><br><span class="line"></span><br><span class="line">kern_return_t kl &#x3D; task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，名为 task_info_t  的结构里包含了一个 resident_size 字段，用于表示使用了多少内存。</p>
<p>当发现有App内存警告，可以借此获取当前 App 占用了多少内存。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float used_memory &#x3D; info.resident_size;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;App占用了 %f MB 的内存&quot;, used_memory &#x2F; 1024.0f &#x2F; 1024.0f);</span><br></pre></td></tr></table></figure>

<p>另外 ,也可以获取当前设备可用的内存, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm_statistics_data_t vmStats;</span><br><span class="line">mach_msg_type_number_t infoCount &#x3D; HOST_VM_INFO_COUNT;</span><br><span class="line">kern_return_t kernReturn &#x3D; host_statistics(mach_host_self(), </span><br><span class="line">                                               HOST_VM_INFO, </span><br><span class="line">                                      (host_info_t)&amp;vmStats, </span><br><span class="line">                                                &amp;infoCount);</span><br><span class="line">float free_memory &#x3D; vm_page_size *vmStats.free_count;</span><br><span class="line">NSLog(@&quot;App可用 %f MB 内存&quot;, free_memory &#x2F; 1024.0f &#x2F; 1024.0f);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>利用RunLoop监控卡顿</title>
    <url>/2020/03/28/2020-3-28/</url>
    <content><![CDATA[<p>利用RunLoop监控卡顿</p>
<p>通过学习了戴铭大神的专栏, Get到了在App开发过程中可以利用Runloop来监控App在运行期间的卡顿,卡顿问题是老生常谈 ,并且很影响用户体验,这里截取部分关键步骤,作为自己的参考.</p>
<p>RunLoop的6种状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry , &#x2F;&#x2F; 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers , &#x2F;&#x2F; 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources , &#x2F;&#x2F; 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting , &#x2F;&#x2F; 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ), &#x2F;&#x2F; 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit , &#x2F;&#x2F; 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities  &#x2F;&#x2F; loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听 RunLoop，首先需要创建一个 CFRunLoopObserverContext 观察者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopObserverContext context &#x3D; &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">runLoopObserver &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);</span><br></pre></td></tr></table></figure>

<p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长.</p>
<p>开启一个子线程监控的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建子线程监控</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    &#x2F;&#x2F;子线程开启一个持续的 loop 用来进行监控</span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        long semaphoreWait &#x3D; dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));</span><br><span class="line">        if (semaphoreWait !&#x3D; 0) &#123;</span><br><span class="line">            if (!runLoopObserver) &#123;</span><br><span class="line">                timeoutCount &#x3D; 0;</span><br><span class="line">                dispatchSemaphore &#x3D; 0;</span><br><span class="line">                runLoopActivity &#x3D; 0;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿</span><br><span class="line">            if (runLoopActivity &#x3D;&#x3D; kCFRunLoopBeforeSources || runLoopActivity &#x3D;&#x3D; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                &#x2F;&#x2F;将堆栈信息上报服务器的代码放到这里</span><br><span class="line">            &#125; &#x2F;&#x2F;end activity</span><br><span class="line">        &#125;&#x2F;&#x2F; end semaphore wait</span><br><span class="line">        timeoutCount &#x3D; 0;</span><br><span class="line">    &#125;&#x2F;&#x2F; end while</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取卡顿的方法堆栈信息</p>
<p>获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int s_fatal_signals[] &#x3D; &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int s_fatal_signal_num &#x3D; sizeof(s_fatal_signals) &#x2F; sizeof(s_fatal_signals[0]);</span><br><span class="line"></span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line">    NSArray *exceptionArray &#x3D; [exception callStackSymbols]; &#x2F;&#x2F;得到当前调用栈信息</span><br><span class="line">    NSString *exceptionReason &#x3D; [exception reason];       &#x2F;&#x2F;非常重要，就是崩溃的原因</span><br><span class="line">    NSString *exceptionName &#x3D; [exception name];           &#x2F;&#x2F;异常类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SignalHandler(int code)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;signal handler &#x3D; %d&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitCrashReport()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;系统错误信号捕获</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;oc未捕获异常的捕获</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br></pre></td></tr></table></figure>

<p>另一种方法是，直接用 PLCrashReporter这个开源的第三方库来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是戴铭大神推荐的获取堆栈信息的方法。具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">NSData *lagData &#x3D; [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];</span><br><span class="line">&#x2F;&#x2F; 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport &#x3D; [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line">&#x2F;&#x2F; 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString &#x3D; [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line">&#x2F;&#x2F;将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure>

<p>搜集到卡顿的方法堆栈信息以后，分析并解决卡顿问题。</p>
<p>(以上内容摘自戴铭的极客时间专栏)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git在终端中的一些常用命令</title>
    <url>/2020/03/26/2020-3-26/</url>
    <content><![CDATA[<p>Git在终端中的一些常用命令</p>
<p>公司以自有服务器搭建gitLab用于代码托管, 虽说有像source tree, Tower等非常好用的可视化git管理软件,但也有很多人热衷于在终端上使用git命令,有种返璞归真的意思,今天就自己简单回顾了一些常用的git命令, 毕竟好记性不如烂笔头.</p>
<p>git mv xxx kkkk</p>
<p>#简便修改git文件的文件名</p>
<p>然后直接commit 提交</p>
<p>git log —oneline</p>
<p>#查看简便log历史</p>
<p>git log —all</p>
<p>#查看所有log所有分支 </p>
<p>git log —graph</p>
<p>#查看可视化log历史</p>
<p>git log —n4</p>
<p>#查看所有log记录的前4条</p>
<p>(commit:保存的快照,tree:相当于文件夹 ,blob:相当于文件)</p>
<p>git cat-file -p 1234567..(hash值)</p>
<p>#通过hash值查看git文件 </p>
<p>git cat-file -t 1234567..(hash值)</p>
<p>#通过hash值查看git文件格式(commit/tree/blob)</p>
<p>git diff 123456 7891011</p>
<p>#通过两个commit的hash值比较变更差异</p>
<p>git diff HEAD HEAD^1^1 (等同于git diff HEAD HEAD^^  或git diff HEAD HEAD~2)</p>
<p>#比较当前HEAD和父HEAD的父HEAD的变更差异</p>
<p>git branch -D 123456(分支名)</p>
<p>#删除指定名字的分支</p>
<p>git commit -amend </p>
<p>#对最近的一次commit的message做修改变更</p>
<p>git rebase -i 1234(需要修改的commit的父commit)</p>
<p>#对历史任意一次commit做变更</p>
<p>git rebase -i  </p>
<p>#pick改为s 进行commit合并</p>
<p>git diff —cached</p>
<p>#比较暂存区和HEAD所含文件的差异</p>
<p>git reset HEAD</p>
<p>#让暂存区恢复成和HEAD的一样,命令后可跟具体</p>
<p>文件名,即可具体到指定文件</p>
<p>git checkout — 文件名</p>
<p>#让工作区的文件恢复为和暂存区一样</p>
<p>git reset —hard 123456(commit的hash值)</p>
<p>#消除最近到指定某次commit的提交</p>
<p>git rm filename</p>
<p>#删除指定文件并同步到暂存区</p>
<p>git stash</p>
<p>#提交工作区文件到暂存区</p>
<p>git stash list</p>
<p>#查看暂存区文件列表</p>
<p>git stash pop</p>
<p>#将暂存区文件恢复到工作区,且暂存区内容清除</p>
<p>git stash apply</p>
<p>##将暂存区文件恢复到工作区,且暂存区内容保留</p>
<p>.gitignore 指定不需要git管理的文件</p>
<p>git clone </p>
<p>#git仓库备份到本地</p>
<p>git push</p>
<p>#本地提交到git仓库</p>
<p>git remote -v</p>
<p>#查看本地和远程建立联系的列表</p>
<p>git merge</p>
<p>#由git智能合并</p>
<p>git push -f</p>
<p>#强制更新(不建议使用)</p>
<p>……暂时写这么多吧</p>
]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于静态分析工具 infer 的简单使用</title>
    <url>/2020/03/05/2020-3-5/</url>
    <content><![CDATA[<p>静态分析工具 infer 的简单使用</p>
<p>在iOS开发中或许会用到一款用于静态分析的工具 - infer, 对于这个工具的出处和原理,网上也有相关介绍.</p>
<p>这里,简单记录一下使用步骤:</p>
<p>1)安装:</p>
<p>​    终端输入:</p>
<p>​    brew install infer</p>
<p>​    涉及到软件更新,依赖库安装,安装时间可能较长,具体依网络状况而定.</p>
<p>2)使用:</p>
<p>​    终端进入项目目录:</p>
<p>​    $ cd &lt;项目所在目录&gt;</p>
<p>​    使用如下命令编译:</p>
<p>​    infer – xcodebuild -target 项目名 -configuration Debug -sdk iphonesimulator</p>
<p>​    接下来终端中会出现日志信息打印.</p>
<p>3)结果</p>
<p>​    在项目所在目录出现 “build”及”infer-out”目录</p>
<p>​    “infer-out”文件夹中有txt,json等相关文件,分析bugs.txt.</p>
<p>4)再次使用</p>
<p>​    由于infer有两种模式:增量与非增量模式</p>
<p>​    a)增量模式:是在第一次运行 “2)中的编译命令” 后,产生了build和infer-out文件夹,</p>
<p>​    再次执行该编译命令时,此时就是增量模式.当项目的代码没有改动时,则此时不会有编译结果, 如果项目代码有新的改动之处,此次编译就只产生新的编译结果.</p>
<p>​    b)非增量模式:当再次执行编译命令前,删除了build和infer-out两个文件夹的时候,执行命令,则会输出所有的编译信息,相当于首次编译的情形.</p>
<p>​    所以手动使用非增量模式的方法:</p>
<p>​    一: 执行编译命令前,先删除build和infer-out文件夹(如果有的话)</p>
<p>​    二: 在编译命令的最后追加”clean”, 即:</p>
<p>​    xcodebuild -target 项目名称 -configuration Debug -sdk iphonesimulator clean</p>
<p>​    对于infer静态分析的原理,感兴趣可以google一下.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔一则</title>
    <url>/2020/02/16/2020-2-16/</url>
    <content><![CDATA[<p>​    昨晚外面还在风雨交加,今天就是个大太阳,就是温度有点低.</p>
<p>​    看今天的网络,仿佛一场自发的摄影大赛,各种抓拍的雪景,虽说疫情当前,但这场短暂的春雪还是给广大网友们带来了一丝快乐,毕竟大家都在家憋坏了……</p>
<p>​    昨晚还看到东南亚一些国家发出了”放弃疫情防治措施”的新闻,貌似那边就是百姓该吃吃该喝喝,社会正常运作的意思,想来疫情程度不同,号称新冠病杀伤力不如Sara,于是放弃抵抗?!</p>
<p>​    昨晚西甲的一场比赛,赛前为”中国加油,武汉加油”的仪式还是挺暖心的…咱武汉同胞要加油!</p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2020/02/15/2020-2-15/</url>
    <content><![CDATA[<p>2020年开年的事,大家都知道了,目前仍然在经历着…</p>
<p>由于各方面政策的原因,一直宅着,那就找点事情捣鼓捣鼓吧:买了云主机,开了VPN,</p>
<p>订了网上课程…其实我只是想搭个个人博客,那么,这就是 2020年 的第一篇博文吧.</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
