<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS底层探秘之isa(前篇)</title>
    <url>/2020/09/10/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A7%98%E4%B9%8Bisa(%E5%89%8D%E7%AF%87)/</url>
    <content><![CDATA[<h3 id="一-iSA是什么"><a href="#一-iSA是什么" class="headerlink" title="一. iSA是什么?"></a>一. iSA是什么?</h3><p>从源码可知:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"isa.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结论: isa是对象alloc的时候，伴随初始化的一个属性,isa底层是一个isa_t结构的联合体.</p>
<p>什么是联合体?</p>
<p>当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)。在C Programming Language 一书中对于联合体是这么描述的：</p>
<p>   1)联合体是一个结构；</p>
<p>   2)它的所有成员相对于基地址的偏移量都为0；</p>
<p>   3)此结构空间要大到足够容纳最”宽”的成员；</p>
<p>   4)其对齐方式要适合其中所有的成员；</p>
<h3 id="二-iSA的结构"><a href="#二-iSA的结构" class="headerlink" title="二. iSA的结构"></a>二. iSA的结构</h3><p>isa_t中包含cls类的指针,以及 ISA_BITFIELD 位域.</p>
<p>什么是位域?</p>
<p>位域指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>其中ISA_BITFIELD在不同环境下有不同定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="三-ISA-BITFIELD参数分析"><a href="#三-ISA-BITFIELD参数分析" class="headerlink" title="三. ISA_BITFIELD参数分析"></a>三. ISA_BITFIELD参数分析</h3><p><img src="arm64.png" alt=""></p>
<p>(上图对应 arm64 架构)</p>
<p><font color=#D2691E>nonpointer</font> ：表示是否对 isa 指针开启指针优化. 0：纯isa指针，1：不⽌是类对象地址,isa 中包含了类信息、对象的引⽤计数等</p>
<p><font color=#D2691E>has_assoc</font> ：关联对象标志位，0没有，1存在</p>
<p><font color=#D2691E>has_cxx_dtor</font>：该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑,</p>
<p>如果没有,则可以更快的释放对象</p>
<p><font color=#D2691E>shiftcls</font>: 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位⽤来存储类指针。</p>
<p><font color=#D2691E>magic</font>：⽤于调试器判断当前对象是真的对象还是没有初始化的空间</p>
<p><font color=#D2691E>weakly_referenced</font>：标志对象是否被指向或者曾经指向⼀个 ARC 的弱变量，没有弱引⽤的对象可以更快释放。</p>
<p><font color=#D2691E>deallocating</font>：标志对象是否正在释放内存</p>
<p><font color=#D2691E>has_sidetable_rc</font>：当对象引⽤计数值⼤于 10 时，则需要借⽤该变量存储进位</p>
<p><font color=#D2691E>extra_rc</font>：当表示该对象的引⽤计数值，实际上是引⽤计数值减 1，例如，如果对象的引⽤计数为 10，那么 extra_rc 为 9。如果引⽤计数⼤于 10，则需要使⽤到下⾯的 has_sidetable_rc。</p>
<p>那么isa具体是怎么运行的呢?</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Lottie动画框架的简单使用</title>
    <url>/2020/04/11/2020-4-11/</url>
    <content><![CDATA[<p>Lottie 是 Airbnb 开源的一个动画框架, 可以支持多平台,如iOS,Android,RN,Flutter等.</p>
<p>和平时iOS开发中用一行行代码编写的动画不同, lottie动画框架是由专业的动画设计师设计的.</p>
<p>然后通过Bodymovin插件进行导出,导出的文件为json文件.</p>
<p>Lottie官方平台网站:</p>
<p><a href="https://lottiefiles.com" target="_blank" rel="noopener">https://lottiefiles.com</a></p>
<p>其原理是将通过由After Effects设计编辑的动画效果,通过json,来映射到iOS相应的动画变换类的属性中,通过CoreAnimation进行动画渲染. 相比手动写动画代码,直接导入json文件着实方便不少.</p>
<p><img src="Loading.gif" alt=""></p>
<p>使用步骤如下:</p>
<p>通过CocoaPods集成Lottie框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pod &#39;lottie-ios&#39;, &#39;~&gt; 3.1.6&#39;#For Swift</span><br><span class="line">pod &#39;lottie-ios&#39;, &#39;~&gt; 2.5.3&#39;#For OC</span><br></pre></td></tr></table></figure>

<p>然后可以尝试在Lottie网站上下载一个json动画文件,拖入到工程中,再将json文件名写入代码中,示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOTAnimationView * animationView &#x3D; [LOTAnimationView animationNamed:@&quot;222-trail-loading&quot;];</span><br><span class="line">animationView.loopAnimation &#x3D; YES;</span><br><span class="line">animationView.frame &#x3D; self.view.bounds;</span><br><span class="line">[self.view addSubview:animationView];</span><br><span class="line">[animationView playWithCompletion:^(BOOL animationFinished) &#123;</span><br><span class="line">    &#x2F;&#x2F;动画完成后执行</span><br><span class="line">    &#x2F;&#x2F;当loopAnimation &#x3D; YES时,循环播放的时候不执行</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>Lottie还有一些其他的属性,如手势联动动画,配合LOTAnimationView 的 animationProgress 属性进行控制;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readonly) BOOL isAnimationPlaying;&#x2F;&#x2F;判断动画是否在播放</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL loopAnimation;&#x2F;&#x2F;是否要循环播放动画</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat animationProgress;&#x2F;&#x2F;自定义动画的播放进度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) CGFloat animationSpeed;&#x2F;&#x2F;自定义动画的播放速度</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) CGFloat animationDuration;&#x2F;&#x2F;自定义动画的播放时长</span><br></pre></td></tr></table></figure>

<p>Lottie也支持自定义页面切换的过场动画,通过设置 present／dismiss controller 转场动画, 在需要转场效果的VC中实现UIViewControllerTransitioningDelegate代理中下面的两个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark -- 定制转场动画</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理返回推出控制器的动画</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123;</span><br><span class="line">  LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名1&quot; fromLayerNamed:@&quot;来自哪个图层的图层名1&quot; toLayerNamed:@&quot;去到哪个图层的图层名1&quot; applyAnimationTransform:NO];</span><br><span class="line">  return animationController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理返回退出控制器的动画</span><br><span class="line">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123;</span><br><span class="line">  LOTAnimationTransitionController *animationController &#x3D; [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@&quot;转场动画json名2&quot; fromLayerNamed:@&quot;来自哪个图层的图层名2&quot; toLayerNamed:@&quot;去到哪个图层的图层名2&quot; applyAnimationTransform:NO];</span><br><span class="line">  return animationController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后两个属性fromLayerNamed,toLayerNamed 可不填</span><br></pre></td></tr></table></figure>

<p>最后附上Lottie的iOS/Mac版官方教程地址:</p>
<p><a href="http://airbnb.io/lottie/#/ios" target="_blank" rel="noopener">http://airbnb.io/lottie/#/ios</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>App耗电量检测</title>
    <url>/2020/04/05/2020-4-5/</url>
    <content><![CDATA[<p>虽说现在iOS手机的电池续航越来越持久了,实在不行还有充电宝,快充设备,耗电量似乎不是问题,对用户感知不明显,用户会觉得是手机整体耗电量大,或者机子老化…</p>
<p>作为iOS开发者,还是要对自己开发的App精益求精,所以耗电量问题实际上还是要研究一下的.查看耗电量问题,需要知道是代码哪个地方出现问题,或者说是哪个线程有问题.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread_act_array_t threads;</span><br><span class="line">mach_msg_type_number_t threadsCount &#x3D; 0;</span><br><span class="line">const task_t thisTask &#x3D; mach_task_self();</span><br><span class="line">kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount);</span><br></pre></td></tr></table></figure>

<p>task_threads 是一个关于线程组的函数，通过这个函数可以获得所有的线程信息数组 threads，线程总数 threadsCount。threads 数组里的线程信息有个结构体 thread_basic_info,该结构体里有一个字段 cpu_usage, cpu_usage 记录了 CPU 使用百分比。</p>
<p>其中thread_basic_info 结构体:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">        time_value_t    user_time;      &#x2F;* user 运行的时间 *&#x2F;</span><br><span class="line">        time_value_t    system_time;    &#x2F;* system 运行的时间 *&#x2F;</span><br><span class="line">        integer_t       cpu_usage;      &#x2F;* CPU 使用百分比 *&#x2F;</span><br><span class="line">        policy_t        policy;         &#x2F;* 有效的计划策略 *&#x2F;</span><br><span class="line">        integer_t       run_state;      &#x2F;* run state (see below) *&#x2F;</span><br><span class="line">        integer_t       flags;          &#x2F;* various flags (see below) *&#x2F;</span><br><span class="line">        integer_t       suspend_count;  &#x2F;* suspend count for thread *&#x2F;</span><br><span class="line">        integer_t       sleep_time;     &#x2F;* 休眠时间 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 cpu_usage 字段，来遍历所有的线程，然后查看是哪个线程的 CPU 使用百分比过高了。</p>
<p>比如某个线程对应的CPU使用率值一直保持很高的数字,比如80%,那可以认为是该线程在耗电。</p>
<p>如果想具体到哪段代码引起了耗电问题, 那就记录该线程对应方法堆栈 ,并反向查找出是哪段代码的问题了。</p>
<p>通过以上步骤，可以快速定位到问题，有针对性地进行Code优化。</p>
<p>遍历检查多个线程信息里的CPU使用率的示例代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)checkCPU_Usage &#123;</span><br><span class="line">    thread_act_array_t threads;</span><br><span class="line">    mach_msg_type_number_t threadsCount &#x3D; 0;</span><br><span class="line">    const task_t thisTask &#x3D; mach_task_self();</span><br><span class="line">    kern_return_t kr &#x3D; task_threads(thisTask, &amp;threads, &amp;threadsCount);</span><br><span class="line">    if (kr !&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        thread_info_data_t threadInfo;</span><br><span class="line">        thread_basic_info_t threadBaseInfo;</span><br><span class="line">        mach_msg_type_number_t threadInfoCount &#x3D; THREAD_INFO_MAX;</span><br><span class="line">        if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) &#x3D;&#x3D; KERN_SUCCESS) &#123;</span><br><span class="line">            threadBaseInfo &#x3D; (thread_basic_info_t)threadInfo;</span><br><span class="line">            if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">                integer_t cpuUsage &#x3D; threadBaseInfo-&gt;cpu_usage &#x2F; 10;</span><br><span class="line">                if (cpuUsage &gt; 80) &#123;</span><br><span class="line">                    NSString *stackStr &#x3D; stackOfThread(threads[i]);</span><br><span class="line">                  	NSLog(@&quot;CPU 使用对应线程堆栈：\n%@&quot;,stackStr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(注:本文参考了戴铭的极客时间专栏)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中获取内存值的方法</title>
    <url>/2020/03/31/2020-3-31/</url>
    <content><![CDATA[<p>iOS 系统提供了一个函数 task_info， 可以获取到当前任务的信息。</p>
<p>调用该函数需要导入头文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;sys&#x2F;sysctl.h&gt;</span><br><span class="line">#import &lt;mach&#x2F;mach.h&gt;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct mach_task_basic_info info;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t size &#x3D; sizeof(info);</span><br><span class="line"></span><br><span class="line">kern_return_t kl &#x3D; task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，名为 task_info_t  的结构里包含了一个 resident_size 字段，用于表示使用了多少内存。</p>
<p>当发现有App内存警告，可以借此获取当前 App 占用了多少内存。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float used_memory &#x3D; info.resident_size;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;App占用了 %f MB 的内存&quot;, used_memory &#x2F; 1024.0f &#x2F; 1024.0f);</span><br></pre></td></tr></table></figure>

<p>另外 ,也可以获取当前设备可用的内存, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm_statistics_data_t vmStats;</span><br><span class="line">mach_msg_type_number_t infoCount &#x3D; HOST_VM_INFO_COUNT;</span><br><span class="line">kern_return_t kernReturn &#x3D; host_statistics(mach_host_self(), </span><br><span class="line">                                               HOST_VM_INFO, </span><br><span class="line">                                      (host_info_t)&amp;vmStats, </span><br><span class="line">                                                &amp;infoCount);</span><br><span class="line">float free_memory &#x3D; vm_page_size *vmStats.free_count;</span><br><span class="line">NSLog(@&quot;App可用 %f MB 内存&quot;, free_memory &#x2F; 1024.0f &#x2F; 1024.0f);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>利用RunLoop监控卡顿</title>
    <url>/2020/03/28/2020-3-28/</url>
    <content><![CDATA[<p>利用RunLoop监控卡顿</p>
<p>通过学习了戴铭大神的专栏, Get到了在App开发过程中可以利用Runloop来监控App在运行期间的卡顿,卡顿问题是老生常谈 ,并且很影响用户体验,这里截取部分关键步骤,作为自己的参考.</p>
<p>RunLoop的6种状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry , &#x2F;&#x2F; 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers , &#x2F;&#x2F; 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources , &#x2F;&#x2F; 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting , &#x2F;&#x2F; 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ), &#x2F;&#x2F; 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit , &#x2F;&#x2F; 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities  &#x2F;&#x2F; loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听 RunLoop，首先需要创建一个 CFRunLoopObserverContext 观察者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopObserverContext context &#x3D; &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">runLoopObserver &#x3D; CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);</span><br></pre></td></tr></table></figure>

<p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长.</p>
<p>开启一个子线程监控的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建子线程监控</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    &#x2F;&#x2F;子线程开启一个持续的 loop 用来进行监控</span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        long semaphoreWait &#x3D; dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));</span><br><span class="line">        if (semaphoreWait !&#x3D; 0) &#123;</span><br><span class="line">            if (!runLoopObserver) &#123;</span><br><span class="line">                timeoutCount &#x3D; 0;</span><br><span class="line">                dispatchSemaphore &#x3D; 0;</span><br><span class="line">                runLoopActivity &#x3D; 0;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿</span><br><span class="line">            if (runLoopActivity &#x3D;&#x3D; kCFRunLoopBeforeSources || runLoopActivity &#x3D;&#x3D; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                &#x2F;&#x2F;将堆栈信息上报服务器的代码放到这里</span><br><span class="line">            &#125; &#x2F;&#x2F;end activity</span><br><span class="line">        &#125;&#x2F;&#x2F; end semaphore wait</span><br><span class="line">        timeoutCount &#x3D; 0;</span><br><span class="line">    &#125;&#x2F;&#x2F; end while</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取卡顿的方法堆栈信息</p>
<p>获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int s_fatal_signals[] &#x3D; &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int s_fatal_signal_num &#x3D; sizeof(s_fatal_signals) &#x2F; sizeof(s_fatal_signals[0]);</span><br><span class="line"></span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line">    NSArray *exceptionArray &#x3D; [exception callStackSymbols]; &#x2F;&#x2F;得到当前调用栈信息</span><br><span class="line">    NSString *exceptionReason &#x3D; [exception reason];       &#x2F;&#x2F;非常重要，就是崩溃的原因</span><br><span class="line">    NSString *exceptionName &#x3D; [exception name];           &#x2F;&#x2F;异常类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SignalHandler(int code)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;signal handler &#x3D; %d&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitCrashReport()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;系统错误信号捕获</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;oc未捕获异常的捕获</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br></pre></td></tr></table></figure>

<p>另一种方法是，直接用 PLCrashReporter这个开源的第三方库来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是戴铭大神推荐的获取堆栈信息的方法。具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取数据</span><br><span class="line">NSData *lagData &#x3D; [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];</span><br><span class="line">&#x2F;&#x2F; 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport &#x3D; [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line">&#x2F;&#x2F; 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString &#x3D; [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line">&#x2F;&#x2F;将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure>

<p>搜集到卡顿的方法堆栈信息以后，分析并解决卡顿问题。</p>
<p>(以上内容摘自戴铭的极客时间专栏)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git在终端中的一些常用命令</title>
    <url>/2020/03/26/2020-3-26/</url>
    <content><![CDATA[<p>Git在终端中的一些常用命令</p>
<p>公司以自有服务器搭建gitLab用于代码托管, 虽说有像source tree, Tower等非常好用的可视化git管理软件,但也有很多人热衷于在终端上使用git命令,有种返璞归真的意思,今天就自己简单回顾了一些常用的git命令, 毕竟好记性不如烂笔头.</p>
<p>git mv xxx kkkk</p>
<p>#简便修改git文件的文件名</p>
<p>然后直接commit 提交</p>
<p>git log —oneline</p>
<p>#查看简便log历史</p>
<p>git log —all</p>
<p>#查看所有log所有分支 </p>
<p>git log —graph</p>
<p>#查看可视化log历史</p>
<p>git log —n4</p>
<p>#查看所有log记录的前4条</p>
<p>(commit:保存的快照,tree:相当于文件夹 ,blob:相当于文件)</p>
<p>git cat-file -p 1234567..(hash值)</p>
<p>#通过hash值查看git文件 </p>
<p>git cat-file -t 1234567..(hash值)</p>
<p>#通过hash值查看git文件格式(commit/tree/blob)</p>
<p>git diff 123456 7891011</p>
<p>#通过两个commit的hash值比较变更差异</p>
<p>git diff HEAD HEAD^1^1 (等同于git diff HEAD HEAD^^  或git diff HEAD HEAD~2)</p>
<p>#比较当前HEAD和父HEAD的父HEAD的变更差异</p>
<p>git branch -D 123456(分支名)</p>
<p>#删除指定名字的分支</p>
<p>git commit -amend </p>
<p>#对最近的一次commit的message做修改变更</p>
<p>git rebase -i 1234(需要修改的commit的父commit)</p>
<p>#对历史任意一次commit做变更</p>
<p>git rebase -i  </p>
<p>#pick改为s 进行commit合并</p>
<p>git diff —cached</p>
<p>#比较暂存区和HEAD所含文件的差异</p>
<p>git reset HEAD</p>
<p>#让暂存区恢复成和HEAD的一样,命令后可跟具体</p>
<p>文件名,即可具体到指定文件</p>
<p>git checkout — 文件名</p>
<p>#让工作区的文件恢复为和暂存区一样</p>
<p>git reset —hard 123456(commit的hash值)</p>
<p>#消除最近到指定某次commit的提交</p>
<p>git rm filename</p>
<p>#删除指定文件并同步到暂存区</p>
<p>git stash</p>
<p>#提交工作区文件到暂存区</p>
<p>git stash list</p>
<p>#查看暂存区文件列表</p>
<p>git stash pop</p>
<p>#将暂存区文件恢复到工作区,且暂存区内容清除</p>
<p>git stash apply</p>
<p>##将暂存区文件恢复到工作区,且暂存区内容保留</p>
<p>.gitignore 指定不需要git管理的文件</p>
<p>git clone </p>
<p>#git仓库备份到本地</p>
<p>git push</p>
<p>#本地提交到git仓库</p>
<p>git remote -v</p>
<p>#查看本地和远程建立联系的列表</p>
<p>git merge</p>
<p>#由git智能合并</p>
<p>git push -f</p>
<p>#强制更新(不建议使用)</p>
<p>……暂时写这么多吧</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于静态分析工具 infer 的简单使用</title>
    <url>/2020/03/05/2020-3-5/</url>
    <content><![CDATA[<p>静态分析工具 infer 的简单使用</p>
<p>在iOS开发中或许会用到一款用于静态分析的工具 - infer, 对于这个工具的出处和原理,网上也有相关介绍.</p>
<p>这里,简单记录一下使用步骤:</p>
<p>1)安装:</p>
<p>​    终端输入:</p>
<p>​    brew install infer</p>
<p>​    涉及到软件更新,依赖库安装,安装时间可能较长,具体依网络状况而定.</p>
<p>2)使用:</p>
<p>​    终端进入项目目录:</p>
<p>​    $ cd &lt;项目所在目录&gt;</p>
<p>​    使用如下命令编译:</p>
<p>​    infer – xcodebuild -target 项目名 -configuration Debug -sdk iphonesimulator</p>
<p>​    接下来终端中会出现日志信息打印.</p>
<p>3)结果</p>
<p>​    在项目所在目录出现 “build”及”infer-out”目录</p>
<p>​    “infer-out”文件夹中有txt,json等相关文件,分析bugs.txt.</p>
<p>4)再次使用</p>
<p>​    由于infer有两种模式:增量与非增量模式</p>
<p>​    a)增量模式:是在第一次运行 “2)中的编译命令” 后,产生了build和infer-out文件夹,</p>
<p>​    再次执行该编译命令时,此时就是增量模式.当项目的代码没有改动时,则此时不会有编译结果, 如果项目代码有新的改动之处,此次编译就只产生新的编译结果.</p>
<p>​    b)非增量模式:当再次执行编译命令前,删除了build和infer-out两个文件夹的时候,执行命令,则会输出所有的编译信息,相当于首次编译的情形.</p>
<p>​    所以手动使用非增量模式的方法:</p>
<p>​    一: 执行编译命令前,先删除build和infer-out文件夹(如果有的话)</p>
<p>​    二: 在编译命令的最后追加”clean”, 即:</p>
<p>​    xcodebuild -target 项目名称 -configuration Debug -sdk iphonesimulator clean</p>
<p>​    对于infer静态分析的原理,感兴趣可以google一下.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔一则</title>
    <url>/2020/02/16/2020-2-16/</url>
    <content><![CDATA[<p>​    昨晚外面还在风雨交加,今天就是个大太阳,就是温度有点低.</p>
<p>​    看今天的网络,仿佛一场自发的摄影大赛,各种抓拍的雪景,虽说疫情当前,但这场短暂的春雪还是给广大网友们带来了一丝快乐,毕竟大家都在家憋坏了……</p>
<p>​    昨晚还看到东南亚一些国家发出了”放弃疫情防治措施”的新闻,貌似那边就是百姓该吃吃该喝喝,社会正常运作的意思,想来疫情程度不同,号称新冠病杀伤力不如Sara,于是放弃抵抗?!</p>
<p>​    昨晚西甲的一场比赛,赛前为”中国加油,武汉加油”的仪式还是挺暖心的…咱武汉同胞要加油!</p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2020/02/15/2020-2-15/</url>
    <content><![CDATA[<p>2020年开年的事,大家都知道了,目前仍然在经历着…</p>
<p>由于各方面政策的原因,一直宅着,那就找点事情捣鼓捣鼓吧:买了云主机,开了VPN,</p>
<p>订了网上课程…其实我只是想搭个个人博客,那么,这就是 2020年 的第一篇博文吧.</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
